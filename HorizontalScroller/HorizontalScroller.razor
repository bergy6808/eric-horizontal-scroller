@typeparam TItem
@using Microsoft.JSInterop
@implements IAsyncDisposable
<div class="parent-wrapper">
    @if (_preRenderMode && ItemTemplate != null && Items != null)
    {
        var itemCount = GetItemsPerSlide();
        <div style="display:flex;gap: @ItemSpacing;">
            @foreach (var item in Items.Take(itemCount))
            {
                <div style="height: 100%;flex-grow: 1;">
                    @ItemTemplate(item)
                </div>
            }
            @if (itemCount > Items.Count())
            {
                @foreach (var _ in Enumerable.Range(0, itemCount - Items.Count()))
                {
                    <div style="height: 100%;flex-grow: 1;"></div>
                }
            }
        </div>
    }
    <div style="@(AllowOverflow ? $"overflow-x: visible;margin-left:-{OverflowAllowedWidthOnLeft};" : "") @(_preRenderMode ? "visibility:hidden;position:absolute;left:0;right:0;top:0;" : "")">
        <div class="scroller-container" style="--item-spacing:@ItemSpacing;--container-width:@_itemsFullWidth;--end-spacer-width:@EndSpacerWidth;width:@(AllowOverflow ? $"calc({OverflowViewportWidth} + {OverflowAllowedWidthOnLeft})" : "initial");padding-left:@(AllowOverflow? OverflowAllowedWidthOnLeft : "0");"
             @onmousedown="EventUtil.AsNonRenderingEventHandler<MouseEventArgs>(OnMouseDown)"
             @onmouseup="EventUtil.AsNonRenderingEventHandler<MouseEventArgs>(OnMouseUp)"
             @onmouseleave="EventUtil.AsNonRenderingEventHandler<MouseEventArgs>(OnMouseUp)"
             @ontouchstart="EventUtil.AsNonRenderingEventHandler<TouchEventArgs>(OnTouchStart)"
             @ontouchend="EventUtil.AsNonRenderingEventHandler<TouchEventArgs>(OnTouchEnd)"
             @ref="_scrollerRef">
            <div class="scroller-content" role="list">
                @if (Items != null && ItemTemplate != null)
                {
                    var relativeWidthItemsCount = UseRelativeWidth() ? GetItemsPerSlide() : (int?)null;
                    @foreach (var item in Items)
                    {
                        <div class="scroller-item @(UseRelativeWidth() ? "item-using-width-per-slide" : "")" style="--items-per-slide:@(relativeWidthItemsCount ?? 1);">
                            <div style="height: 100%;@(relativeWidthItemsCount != null ? "" : $"width:{ItemWidth};") @(EnableDrag ? "user-select: none;" : "")">
                                @if (!_preRenderMode)
                                {
                                    @ItemTemplate(item)
                                }
                                else
                                {
                                    <div></div>
                                }
                            </div>
                        </div>
                    }

                    <div class="scroller-end-spacer"></div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    /// <summary>
    /// Items
    /// </summary>
    [Parameter, EditorRequired] public IEnumerable<TItem>? Items { get; set; }

    /// <summary>
    /// Content template for each item. Use @context to access the item.
    /// </summary>
    [Parameter, EditorRequired] public RenderFragment<TItem>? ItemTemplate { get; set; }
    /// <summary>
    /// If setting true, you might want to add "overflow-x: hidden;" to an ancestor div being full-width
    /// </summary>
    [Parameter] public bool AllowOverflow { get; set; }

    /// <summary>
    /// Spacing between items
    /// </summary>
    [Parameter] public string ItemSpacing { get; set; } = "1rem";

    /// <summary>
    /// Sets the width of items. Has priority over ItemsPerSlideSelector. Consider 75vw for mobile.
    /// </summary>
    [Parameter] public string ItemWidth { get; set; } = "auto";

    /// <summary>
    /// Scroll div width, if AllowOverflow is true
    /// </summary>
    [Parameter] public string OverflowViewportWidth { get; set; } = "100%";

    /// <summary>
    /// Allowed overflow on the left, if AllowOverflow is true
    /// </summary>
    [Parameter] public string OverflowAllowedWidthOnLeft { get; set; } = "10rem";

    /// <summary>
    /// Extra space at the end to allow snapping on the last element
    /// </summary>
    [Parameter] public string EndSpacerWidth { get; set; } = "300px";

    /// <summary>
    /// If true, the scroller will have inertia when dragging. Speed will decay at a rate of InertiaDecay.
    /// </summary>
    [Parameter] public bool EnableInertia { get; set; } = true;

    /// <summary>
    /// Decay rate of the inertia. 1.0 means no decay (it will scroll by itself forever), 0.0 means instant stop.
    /// </summary>
    [Parameter] public double InertiaDecay { get; set; } = 0.9;

    /// <summary>
    /// Defaults to true. If false, the scroller will not respond to mouse/touch events.
    /// </summary>
    [Parameter] public bool EnableDrag { get; set; } = true;

    /// <summary>
    /// When drag is released and reached a minimum speed, the scroller will snap to the closest item (if true). Otherwise, it will just stop where it is.
    /// </summary>
    [Parameter] public bool EnableSnapping { get; set; } = true;

    /// <summary>
    /// Delays between reaching minimum speed (after dragging) and snapping to the closest item.
    /// </summary>
    [Parameter] public int SnapDelay { get; set; } = 100;

    /// <summary>
    /// Carousel mode enables items to take the full width of the available space (or share equally whit others using CarouselItemsPerSlideSelector)
    /// </summary>
    [Parameter, Obsolete("Use ItemsPerSlideSelector and don't specify ItemWidth", true)] public bool CarouselMode { get; set; }

    /// <summary>
    /// If ItemWidth is "auto", and if not null, width of item will be decided by this
    /// </summary>
    [Parameter] public Func<WidthInfo?, int>? ItemsPerSlideSelector { get; set; }

    /// <summary>
    /// Sets the selected slide index.
    /// </summary>
    [Parameter] public int SelectedIndex { get; set; }
    /// <summary>
    /// Callback on selected slide changed
    /// </summary>
    [Parameter] public EventCallback<int> SelectedIndexChanged { get; set; }
    /// <summary>
    /// Callback on landing on an index
    /// </summary>
    [Parameter] public EventCallback<int> OnSnapped { get; set; }

    [Inject] private IJSRuntime Js { get; set; } = null!;


    private ElementReference? _scrollerRef;
    private IJSObjectReference? _scrollerModule;
    private DotNetObjectReference<HorizontalScroller<TItem>>? _dotNetRef;
    private string _itemsFullWidth = "75vw";
    private WidthInfo? _widthInfo;
    private int _selectedIndex;
    private bool _isDragging;
    private bool _preRenderMode;

    protected override void OnInitialized()
    {
        _preRenderMode = UseRelativeWidth() && Items != null && ItemTemplate != null;
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_scrollerModule != null && _selectedIndex != SelectedIndex && !_isDragging)
        {
            await SnapToIndexAsync(SelectedIndex, false);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
#if DEBUG
        const string moduleLocation = "./_content/BlazorHorizontalScroller/horizontalScroller.js";
#else
        const string moduleLocation = "./_content/BlazorHorizontalScroller/horizontalScroller.min.js";
#endif
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            _scrollerModule = await Js.InvokeAsync<IJSObjectReference>("import", moduleLocation);
            if (_scrollerModule != null)
            {
                await _scrollerModule.InvokeVoidAsync("initScroller", _scrollerRef, _dotNetRef, new
                {
                    startIndex = SelectedIndex,
                    snapDelay = SnapDelay,
                    inertiaDecay = (!EnableInertia ? 0.0 : InertiaDecay),
                    enableSnapping = EnableSnapping,
                    enableDrag = EnableDrag
                });
            }
        }
        await SyncWidth();
        _preRenderMode = false;
    }

    private async Task SyncWidth()
    {
        if (_scrollerModule != null && (UseRelativeWidth()))
            _widthInfo = await _scrollerModule.InvokeAsync<WidthInfo>("getSizeInfo", _scrollerRef);
        FullWidthChanged();
    }

    private async Task OnMouseDown(MouseEventArgs e)
    {
        if (_scrollerModule != null && EnableDrag)
        {
            await _scrollerModule.InvokeVoidAsync("startDrag", _scrollerRef, e.ClientX);
            _isDragging = true;
        }
    }

    private async Task OnMouseUp(MouseEventArgs e)
    {
        if (_scrollerModule != null)
        {
            await _scrollerModule.InvokeVoidAsync("endDrag", _scrollerRef);
            _isDragging = false;
        }
    }

    private async Task OnTouchStart(TouchEventArgs e)
    {
        if (_scrollerModule != null && e.Touches.Length > 0 && EnableDrag)
        {
            await _scrollerModule.InvokeVoidAsync("startDrag", _scrollerRef, e.Touches[0].ClientX);
            _isDragging = true;
        }
    }

    private async Task OnTouchEnd(TouchEventArgs e)
    {
        if (_scrollerModule != null)
        {
            await _scrollerModule.InvokeVoidAsync("endDrag", _scrollerRef);
            _isDragging = false;
        }
    }
    /// <summary>
    /// Goes to the next item
    /// </summary>
    public async Task SnapToNextItem()
    {
        if (_scrollerModule != null)
            await _scrollerModule.InvokeVoidAsync("snapToNext", _scrollerRef);
    }
    /// <summary>
    /// Goes to the next slide. Will be different if ItemsPerSlideSelector returns something > 1.
    /// </summary>
    public async Task SnapToNextSlide()
    {
        var increment = GetItemsPerSlide();
        await SnapToIndexAsync(_selectedIndex + increment);
    }

    /// <summary>
    /// Goes to the previous item
    /// </summary>
    public async Task SnapToPreviousItem()
    {
        if (_scrollerModule != null)
            await _scrollerModule.InvokeVoidAsync("snapToPrevious", _scrollerRef);
    }
    /// <summary>
    /// Goes to the previous slide. Will be different if ItemsPerSlideSelector returns something > 1.
    /// </summary>
    public async Task SnapToPreviousSlide()
    {
        var increment = - GetItemsPerSlide();
        await SnapToIndexAsync(_selectedIndex + increment);
    }
    /// <summary>
    /// Goes to a specific item index 
    /// </summary>
    /// <param name="index"></param>
    /// <returns></returns>
    public async Task SnapToItemIndex(int index)
    {
        await SnapToIndexAsync(index);
    }
    /// <summary>
    /// Goes to a specific slide index. Will be different if ItemsPerSlideSelector returns something > 1.
    /// </summary>
    /// <param name="index"></param>
    /// <returns></returns>
    public async Task SnapToSlideIndex(int index)
    {
        var itemIndex = GetItemsPerSlide() * index;
        await SnapToIndexAsync(itemIndex);
    }

    private async Task SnapToIndexAsync(int index, bool priority = true)
    {
        if (_scrollerModule != null)
        {
            //_selectedIndex = index;
            await _scrollerModule.InvokeVoidAsync("snapToIndex", _scrollerRef, index, "smooth", priority);
        }
    }


    private int GetItemsPerSlide() => UseRelativeWidth() ? (ItemsPerSlideSelector?.Invoke(_widthInfo) ?? 1) : 1;

    private bool UseRelativeWidth() => ItemWidth == "auto" && ItemsPerSlideSelector != null;

    [JSInvokable]
    public async Task NotifySnapToIndex(int index)
    {
        await NotifyNearestIndexChanged(index);
        await OnSnapped.InvokeAsync(index);
    }
    [JSInvokable]
    public async Task NotifyNearestIndexChanged(int index)
    {
        if (SelectedIndex != index)
        {
            SelectedIndex = index;
            _selectedIndex = index;
            await SelectedIndexChanged.InvokeAsync(index);
        }
    }
    [JSInvokable]
    public Task ResizedParent(WidthInfo widthInfo)
    {
        _widthInfo = widthInfo;
        FullWidthChanged();
        return Task.CompletedTask;
    }

    private void FullWidthChanged()
    {
        if (_widthInfo != null)
        {
            var expectedValue = $"{_widthInfo.ParentWidth}px";
            if (expectedValue != _itemsFullWidth)
            {
                _itemsFullWidth = expectedValue;
                StateHasChanged();
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_scrollerModule != null)
                await _scrollerModule.DisposeAsync();
        }
        catch (Exception)
        {
            // ignored
        }

        _dotNetRef?.Dispose();
    }

    private static class EventUtil
    {
        public static Func<TValue, Task> AsNonRenderingEventHandler<TValue>(
            Func<TValue, Task> callback)
            => new AsyncReceiver<TValue>(callback).Invoke;

        private record AsyncReceiver<T>(Func<T, Task> Callback)
            : ReceiverBase
        { public Task Invoke(T arg) => Callback(arg); }

        private record ReceiverBase : IHandleEvent
        {
            public Task HandleEventAsync(EventCallbackWorkItem item, object? arg) =>
                item.InvokeAsync(arg);
        }
    }

}