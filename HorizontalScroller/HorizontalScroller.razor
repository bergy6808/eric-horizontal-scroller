@*
A big thank you to ChatGPT for helping creating this!
*@

@typeparam TItem
@using Microsoft.JSInterop
@implements IAsyncDisposable
<div class="parent-wrapper">
    <div style="@(AllowOverflow ? $"overflow-x: visible;margin-left:-{OverflowAllowedWidthOnLeft};" : "")">
        <div class="scroller-container" style="--item-spacing:@ItemSpacing;--carousel-slide-width:@_itemsFullWidth;--end-spacer-width:@EndSpacerWidth;width:@(AllowOverflow ? $"calc({OverflowViewportWidth} + {OverflowAllowedWidthOnLeft})" : "initial");padding-left:@(AllowOverflow? OverflowAllowedWidthOnLeft : "0");"
             @onmousedown="OnMouseDown"
             @onmouseup="OnMouseUp"
             @onmouseleave="OnMouseUp"
             @ontouchstart="OnTouchStart"
             @ontouchend="OnTouchEnd"
             @ref="_scrollerRef">
            <div class="scroller-content" role="list">
                @if (Items != null && ItemTemplate != null)
                {
                    var batchSize = CarouselMode ? CarouselItemsPerSlideSelector(_widthInfo) : 1;
                    @foreach (var batch in Items.Chunk(batchSize <= 0 ? 1 : batchSize))
                    {
                        <div class="scroller-item">
                            <div class="@(CarouselMode ? "carousel-slide" : "")" style="height: 100%;@(CarouselMode ? "" : $"width:{ItemWidth};") @(EnableDrag ? "user-select: none;" : "")">
                                @foreach (var item in batch)
                                {
                                    @ItemTemplate(item)
                                }
                            </div>
                        </div>
                    }
                    <div class="scroller-end-spacer"></div>
                }
            </div>
        </div>
    </div>
</div>

@code {
    /// <summary>
    /// Items
    /// </summary>
    [Parameter, EditorRequired] public IEnumerable<TItem>? Items { get; set; }

    /// <summary>
    /// Content template for each item. Use @context to access the item. If not using CarouselMode, you should fix the width of the items yourself.
    /// </summary>
    [Parameter, EditorRequired] public RenderFragment<TItem>? ItemTemplate { get; set; }
    /// <summary>
    /// If setting true, you might want to add "overflow-x: hidden;" to an ancestor div being full-width
    /// </summary>
    [Parameter] public bool AllowOverflow { get; set; }

    /// <summary>
    /// Spacing between items
    /// </summary>
    [Parameter] public string ItemSpacing { get; set; } = "1rem";

    /// <summary>
    /// When carousel mode is off, sets the width of items. Consider 75vw for mobile
    /// </summary>
    [Parameter] public string ItemWidth { get; set; } = "auto";

    /// <summary>
    /// Scroll div width, if AllowOverflow is true
    /// </summary>
    [Parameter] public string OverflowViewportWidth { get; set; } = "100%";

    /// <summary>
    /// Allowed overflow on the left, if AllowOverflow is true
    /// </summary>
    [Parameter] public string OverflowAllowedWidthOnLeft { get; set; } = "10rem";

    /// <summary>
    /// Extra space at the end to allow snapping on the last element
    /// </summary>
    [Parameter] public string EndSpacerWidth { get; set; } = "300px";

    /// <summary>
    /// If true, the scroller will have inertia when dragging. Speed will decay at a rate of InertiaDecay.
    /// </summary>
    [Parameter] public bool EnableInertia { get; set; } = true;

    /// <summary>
    /// Decay rate of the inertia. 1.0 means no decay (it will scroll by itself forever), 0.0 means instant stop.
    /// </summary>
    [Parameter] public double InertiaDecay { get; set; } = 0.9;

    /// <summary>
    /// Defaults to true. If false, the scroller will not respond to mouse/touch events.
    /// </summary>
    [Parameter] public bool EnableDrag { get; set; } = true;

    /// <summary>
    /// When drag is released and reached a minimum speed, the scroller will snap to the closest item (if true). Otherwise, it will just stop where it is.
    /// </summary>
    [Parameter] public bool EnableSnapping { get; set; } = true;

    /// <summary>
    /// Delays between reaching minimum speed (after dragging) and snapping to the closest item.
    /// </summary>
    [Parameter] public int SnapDelay { get; set; } = 100;

    /// <summary>
    /// Carousel mode enables items to take the full width of the available space (or share equally whit others using CarouselItemsPerSlideSelector)
    /// </summary>
    [Parameter] public bool CarouselMode { get; set; }

    /// <summary>
    /// If component is in CarouselMode, each carousel slide will have this number of items. You can choose from either parent size of viewport size, but watch out: WidthInfo is null on first render
    /// </summary>
    [Parameter] public Func<WidthInfo?, int> CarouselItemsPerSlideSelector { get; set; } = _ => 1;

    /// <summary>
    /// Sets the selected slide index. 
    /// </summary>
    [Parameter] public int SelectedIndex { get; set; }
    /// <summary>
    /// Callback on selected slide changed
    /// </summary>
    [Parameter] public EventCallback<int> SelectedIndexChanged { get; set; }

    [Inject] private IJSRuntime Js { get; set; } = null!;


    private ElementReference? _scrollerRef;
    private IJSObjectReference? _scrollerModule;
    private DotNetObjectReference<HorizontalScroller<TItem>>? _dotNetRef;
    private string _itemsFullWidth = "75vw";
    private WidthInfo? _widthInfo;
    private int _selectedIndex;
    private bool _isDragging;

    protected override async Task OnParametersSetAsync()
    {
        if (_scrollerModule != null && _selectedIndex != SelectedIndex && !_isDragging)
        {
            await SnapToIndexAsync(SelectedIndex);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
#if DEBUG
        const string moduleLocation = "./_content/BlazorHorizontalScroller/horizontalScroller.js";
#else
        const string moduleLocation = "./_content/BlazorHorizontalScroller/horizontalScroller.min.js";
#endif
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            _scrollerModule = await Js.InvokeAsync<IJSObjectReference>("import", moduleLocation);
            if (_scrollerModule != null)
            {
                await _scrollerModule.InvokeVoidAsync("initScroller", _scrollerRef, _dotNetRef, new
                {
                    startIndex = SelectedIndex,
                    snapDelay = SnapDelay,
                    inertiaDecay = (!EnableInertia ? 0.0 : InertiaDecay),
                    enableSnapping = EnableSnapping,
                    enableDrag = EnableDrag
                });
            }
        }
        await SyncWidth();
    }

    private async Task SyncWidth()
    {
        if (_scrollerModule != null && CarouselMode)
            _widthInfo = await _scrollerModule.InvokeAsync<WidthInfo>("getSizeInfo", _scrollerRef);
        FullWidthChanged();
    }

    private async Task OnMouseDown(MouseEventArgs e)
    {
        if (_scrollerModule != null && EnableDrag)
        {
            await _scrollerModule.InvokeVoidAsync("startDrag", _scrollerRef, e.ClientX);
            _isDragging = true;
        }
    }

    private async Task OnMouseUp(MouseEventArgs e)
    {
        if (_scrollerModule != null)
        {
            await _scrollerModule.InvokeVoidAsync("endDrag", _scrollerRef);
            _isDragging = false;
        }
    }

    private async Task OnTouchStart(TouchEventArgs e)
    {
        if (_scrollerModule != null && e.Touches.Length > 0 && EnableDrag)
        {
            await _scrollerModule.InvokeVoidAsync("startDrag", _scrollerRef, e.Touches[0].ClientX);
            _isDragging = true;
        }
    }

    private async Task OnTouchEnd(TouchEventArgs e)
    {
        if (_scrollerModule != null)
        {
            await _scrollerModule.InvokeVoidAsync("endDrag", _scrollerRef);
            _isDragging = false;
        }
    }
    public async Task SnapToNextAsync()
    {
        if (_scrollerModule != null)
            await _scrollerModule.InvokeVoidAsync("snapToNext", _scrollerRef);
    }

    public async Task SnapToPreviousAsync()
    {
        if (_scrollerModule != null)
            await _scrollerModule.InvokeVoidAsync("snapToPrevious", _scrollerRef);
    }
    public async Task SnapToIndexAsync(int index)
    {
        if (_scrollerModule != null)
        {
            _selectedIndex = index;
            await _scrollerModule.InvokeVoidAsync("snapToIndex", _scrollerRef, index);
        }
    }
    [JSInvokable]
    public async Task NotifySnapToIndex(int index)
    {
        if (SelectedIndex != index)
        {
            SelectedIndex = index;
            _selectedIndex = index;
            await SelectedIndexChanged.InvokeAsync(index);
        }
    }
    [JSInvokable]
    public async Task NotifyNearestIndexChanged(int index)
    {
        if (SelectedIndex != index)
        {
            SelectedIndex = index;
            _selectedIndex = index;
            await SelectedIndexChanged.InvokeAsync(index);
        }
    }
    [JSInvokable]
    public Task ResizedParent(WidthInfo widthInfo)
    {
        _widthInfo = widthInfo;
        FullWidthChanged();
        return Task.CompletedTask;
    }

    private void FullWidthChanged()
    {
        if (_widthInfo != null)
        {
            var expectedValue = $"{_widthInfo.ParentWidth}px";
            if (expectedValue != _itemsFullWidth)
            {
                _itemsFullWidth = expectedValue;
                StateHasChanged();
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_scrollerModule != null)
                await _scrollerModule.DisposeAsync();
        }
        catch (Exception)
        {
            // ignored
        }

        _dotNetRef?.Dispose();
    }


}